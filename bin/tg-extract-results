#!/bin/bash

# Extract results from a number of runs.

# Given output from a run-* front end, extract the mean and median errors
# from each specified file, compute the avg mean/median error, and output
# a line giving the errors along with relevant parameters for that particular
# run.

sort=
avgsort=
meansort=
mediansort=
accsort=
numevalsort=
numtrainsort=
namesort=
runtimesort=
verbose=
debug=
while true; do
  case "$1" in
    --no-sort ) sort=no; shift ;;
    --sort | --sort-average | --sort-avg ) sort=yes ; avgsort=yes; shift ;;
    --sort-mean ) sort=yes ; meansort=yes; shift ;;
    --sort-median ) sort=yes ; mediansort=yes; shift ;;
    --sort-accuracy | --sort-acc ) sort=yes ; accsort=yes; shift ;;
    --sort-numeval ) sort=yes ; numevalsort=yes; shift ;;
    --sort-numtrain ) sort=yes ; numtrainsort=yes; shift ;;
    --sort-file | --sort-name ) sort=yes ; namesort=yes; shift ;;
    --sort-runtime ) sort=yes ; runtimesort=yes; shift ;;
    --verbose ) verbose=yes ; shift ;;
    --debug ) debug=yes ; shift ;;
    -- ) shift ; break ;;
    -*) echo "Unrecognized argument: $1"; exit 1 ;;
    * ) break ;;
  esac
done

if [ -z "$sort" ]; then
  sort=yes
  avgsort=yes
fi

if [ "$verbose" != yes ]; then
  echo "  #Eval   #Train  %Accur. Mean   Median  Average  Runtime    RSS    File"
fi

function output() {
for x in ${1+"$@"}; do
  if [ -n "$debug" ]; then
    echo "[$x]"
    echo ""
  fi
  args=$(grep -m 1 '^Nohup script invoked as:.* --full-id ' "$x")
  if [ -n "$args" ]; then
    args=$(echo $args | perl -pe 's/^.*? --full-id (\S+) .*$/$1/')
  else
    args=$(grep -m 1 '^Arguments:' "$x")
    args=$(echo $args | perl -pe 's/^Arguments: //;' -e 's/--input(-corpus)? [^ ]*\///')
    args=$(echo $args | perl -pe 's/  *--*([^ ]*)  *([^-][^ ]*)/ $1=$2/g;' -e 's/  *--*([^ ]*)/ $1/g;' -e 's/ /./g;' -e 's/\//-/g;')
  fi
  results=$(sed -n '/^Final results/,/^Ending final results/p' "$x")
  mean=$(echo "$results" | egrep 'Mean true error' | perl -pe 's/^.*distance = +(\S+).*/$1/')
  median=$(echo "$results" | egrep 'Median true error' | perl -pe 's/^.*distance = +(\S+).*/$1/')
  avg=
  if [ -n "$mean" -a -n "$median" ]; then
    if [ -n "$debug" ]; then
      echo "Extracted mean: [$mean]"
      echo "Extracted median: [$median]"
    fi
    avg=$(echo "2k $mean $median + 2/p" | dc)
  fi
  acc=$(echo "$results" | egrep 'Percent correct at rank <= 1 =' | perl -pe 's/.*= (.*?)%.*/$1/')
  numeval=$(echo "$results" | egrep 'Number of instances' | perl -pe 's/.*= (.*?) *$/$1/')
  numtrain=$(echo "$results" | egrep 'bytask.*num_training_documents_by_split\.training =' | head -n 1 | perl -pe 's/.*= (.*?) *$/$1/')
  finalstats=$(sed -n '/^Ending final results/,/^Program running time/p' "$x")
  # Convert runtime from "24 minutes 5 seconds" or "0 minutes 6 seconds"
  # (old style) or "24 min 5 sec" or "6 sec" (new style) to a raw version
  # of HH:MM:SS.
  runtime0=$(echo "$finalstats" | egrep 'Program running time:' | perl -pe 's/.*: //;' -e 's/ (hour|hr)s? /:/;' -e 's/ min(ute)?s? /:/;' -e 's/ sec(ond)s?//;')
  if [ -n "$debug" ]; then
    echo "Runtime0: [$runtime0]"
  fi
  # Reformat to proper HH:MM:SS, making sure to have two digits for the
  # minutes.
  runtime=$(echo "$runtime0" | perl -ne '
    my ($hrs, $mins, $secs) = /^(?:(.*?):)?(?:(.*?):)?(.*?)$/;
    # We may have only a number of seconds; check for this.
    if (!defined($hrs)) { $hrs = 0; }
    if (!defined($mins)) { $mins = $hrs; $hrs = 0; }
    $mins = sprintf("%02d", $mins);
    $secs = sprintf("%04.1f", $secs);
    if ($hrs == 0) { $hrs = ""; } else { $hrs = "${hrs}:"; }
    print("$hrs$mins:$secs");
  ')
  # Check for the old way of outputting and convert to new-style (618.63 MB).
  # The old style had various lines beginning "Memory usage" for different
  # usage stats, and had the resident size given as something like
  #
  # Memory usage, actual (i.e. resident set) (proc): 618,635,264 bytes
  #
  rss=$(echo "$finalstats" | egrep 'Memory usage, actual' | perl -pe 's/.*: (.*?) bytes/$1/')
  if [ -n "$rss" ]; then
    rss=$(echo "$rss" | perl -ne '
      my ($rss) = /^(.*)$/;
      $rss =~ s/,//g;
      $rss = $rss + 0; # Make sure string interpreted as number, maybe not nec
      if ($rss >= 1_000_000_000) { printf("%.2f GB", $rss/1_000_000_000.0); }
      elsif ($rss >= 1_000_000) { printf("%.2f MB", $rss/1_000_000.0); }
      else { printf("%.2f KB", $rss/1_000.0); }
    ')
  else
    # The new way, which lines like
    #
    # Memory usage: virtual: 13.51 GB, resident: 1.49 GB, Java heap: 59.61 MB
    #
    rss=$(echo "$finalstats" | egrep 'Memory usage:' | perl -pe 's/.*resident: (.*?B).*$/$1/')
  fi
  if [ -n "$mean" -o -n "$median" -o -n "$avg" -o -n "$acc" ]; then
    skip=no
  else
    skip=yes
  fi
  numeval=$(printf '%7s' "$numeval")
  numtrain=$(printf '%8s' "$numtrain")
  acc=$(printf '%6s' "$acc")
  mean=$(printf '%7s' "$mean")
  median=$(printf '%7s' "$median")
  avg=$(printf '%7s' "$avg")
  runtime=$(printf '%9s' "$runtime")
  rss=$(printf '%9s' "$rss")
  if [ -n "$debug" ]; then
    echo "Args: [$args]"
    echo "Mean: [$mean]"
    echo "Median: [$median]"
    echo "Average: [$avg]"
    echo "%Accuracy: [$acc]"
    echo "#Eval: [$numeval]"
    echo "#Train: [$numtrain]"
    echo "Runtime: [$runtime]"
    echo "RSS: [$rss]"
  fi
  if [ "$verbose" = yes ]; then
    echo "$results" | grep 'true error' | perl -ne "print '$args', '  ', \$_"
    if [ -n "$avg" ]; then
      echo "$args   Avg-mean-median true error distance = $avg km"
    fi
  elif [ "$skip" = no ]; then
    echo "$numeval $numtrain $acc $mean $median $avg $runtime $rss $args"
  fi
done
}

if [ "$namesort" = yes ]; then
  output ${1+"$@"} | sort -k 9
elif [ "$runtimesort" = yes ]; then
  output ${1+"$@"} | sort -nr -k 8
elif [ "$avgsort" = yes ]; then
  output ${1+"$@"} | sort -n -k 6
elif [ "$meansort" = yes ]; then
  output ${1+"$@"} | sort -n -k 4
elif [ "$mediansort" = yes ]; then
  output ${1+"$@"} | sort -n -k 5
elif [ "$accsort" = yes ]; then
  output ${1+"$@"} | sort -nr -k 3
elif [ "$numevalsort" = yes ]; then
  output ${1+"$@"} | sort -nr -k 1
elif [ "$numtrainsort" = yes ]; then
  output ${1+"$@"} | sort -nr -k 2
else
  output ${1+"$@"}
fi

