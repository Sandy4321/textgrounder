#!/bin/sh

# Amount of memory (in megabytes) to reserve for system operation when
# setting the maximum heap size.
RESERVED_MEMORY=1024

TEXTGROUNDER_VERSION=0.3.0

if [ -z "$TEXTGROUNDER_DIR" ]; then
  echo "Must set TEXTGROUNDER_DIR to top level of TextGrounder distribution"
  exit 1
fi

JARS="`echo $TEXTGROUNDER_DIR/lib/*.jar $TEXTGROUNDER_DIR/lib_managed/*/*.jar $TEXTGROUNDER_DIR/lib_managed/*/*/*.jar $TEXTGROUNDER_DIR/lib_managed/*/*/*/*.jar $TEXTGROUNDER_DIR/output/*.jar $TEXTGROUNDER_DIR/target/*.jar | tr ' ' ':'`"
SCALA_LIB="$HOME/.sbt/boot/scala-2.9.1/lib/scala-library.jar"

CP="$TEXTGROUNDER_DIR/target/classes:$SCALA_LIB:$JARS:$CLASSPATH"

JAVA="$JAVA_HOME/bin/java"

VERBOSE=false
DEBUG=false

# Process options

JAVA_HEAP_OPT=
while true; do
  case "$1" in
    -verbose | --verbose ) VERBOSE=true; shift ;;
    -debug | --debug ) DEBUG=true; shift ;;
    -m | -memory | --memory ) MEMORY="$2"; shift 2 ;;
    -minheap | --minheap )
      JAVA_HEAP_OPT="$JAVA_HEAP_OPT -XX:MinHeapFreeRatio=$2"; shift 2 ;;
    -maxheap | --maxheap )
      JAVA_HEAP_OPT="$JAVA_HEAP_OPT -XX:MaxHeapFreeRatio=$2"; shift 2 ;;
    * ) break ;;
  esac
done

# For info on Sun JVM options, see:

# http://java.sun.com/docs/hotspot/VMOptions.html
#
# (redirects to:
#
# http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html
#
# )
#
# Also see the following for tuning garbage collection:
#
# http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html

# Try to set the maximum heap size to something slightly less than
# the physical memory of the machine.  
if [ -z "$MEMORY" ]; then
  MEMMB=`$TEXTGROUNDER_DIR/bin/textgrounder-memory`
  if [ "$VERBOSE" = true ]; then
    echo "Output from textgrounder-memory is: $MEMMB"
  fi
  if [ "$MEMMB" = unknown ]; then
    # The old way we set the heap size, to a very high virtual size.
    if [ -z "$MEMORY" ]; then
      if $JAVA -version 2>&1 | grep '64-Bit' > /dev/null; then
       JAVA_IS_64=true
       # Maximum on Linux is about 127t (127 TB, i.e. 130,048 GB).  Maximum on
       # MacOS X 10.6 (Snow Leopard) is about 125t, but values that big cause a
       # pause of about 6 seconds at the beginning and a couple of seconds at
       # the end on my 4GB Mac.  4t doesn't cause much of a pause.
       MEMORY=4t
      else
       JAVA_IS_64=false
       MEMORY=2g
      fi
    fi
  else
    MEMORY="`expr $MEMMB - $RESERVED_MEMORY`m"
  fi
fi

if [ "$VERBOSE" = true ]; then
  echo "Setting maximum JVM heap size to $MEMORY"
fi

JAVA_MEMORY_OPT="-Xmx$MEMORY"

if [ "$DEBUG" = true ]; then
  # Print details about when and how garbage collection happens; recommended
  # in http://www.oracle.com/technetwork/java/gc-tuning-5-138395.html
  JAVA_DEBUG_OPT="-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+TraceClassUnloading"
  #This will output a lot of stuff about class loading.
  #JAVA_DEBUG_OPT="$JAVA_DEBUG_OPT -XX:+TraceClassLoading"
fi

JAVA_COMMAND="$JAVA $JAVA_MEMORY_OPT $JAVA_DEBUG_OPT $JAVA_HEAP_OPT -classpath $CP"
#SCALA_COMMAND="scala -classpath $CP"
#Running Scala using Java currently works, and ensures that we will run
#properly even if Scala isn't installed on the system or an older version
#is installed. (Since we download our own Scala libraries.)
SCALA_COMMAND="$JAVA_COMMAND"

CMD="$1"
shift

help()
{
cat <<EOF
TextGrounder $TEXTGROUNDER_VERSION usage:
  textgrounder [OPTIONS ...] COMMAND [ARGS ...]

Options:
  --memory MEM          specify maximum heap size (e.g. 2048m or 20g)
  --verbose             show what commands are being executed
  --debug               tell the JVM to output debugging info
  --minheap RATIO, --maxheap RATIO
                        Set the minimum and maximum heap ratios.  If the JVM
                        is hogging memory, try --minheap 20 --maxheap 40
                        to make it more aggressively release memory to the OS
                        (or --minheap 10 --maxheap 20 to be even more
                        aggressive).

General commands:

  build-all             build TextGrounder from source using SBT
  build                 enter SBT command line, to issue further commands
  build COMMAND ...     run SBT using some other arbitrary command(s)
  run CLASS ...         run the main method of a given class
  help                  output this help message

Commands for toponym resolution:

  import-gazetteer ...  import a gazetteer from raw form to serialized form
  import-corpus ...     import a corpus from raw form to serialized form
  preprocess-labelprop ...
                        preprocess label propagation
  geotext-lp ...        run GeoText label propagation resolver
  resolve ...           run the toponomy resolver
  write-to-kml ...      write a resolved corpus to visualizable KML format
  eval ...              evaluated a resolved corpus against a gold corpus

Commands for geolocation:
  geolocate ...         run the geolocation module

Commands for the Bayesian code:
  rlda-run ...          train region model
  spher-run ...         train spherical model
  rlda-fcrm-run ...     train fully-constrained region model
  rlda-convert-from ... convert from region-model format
  rlda-convert-to ...   convert to region-model format
  rlda-prob-out ...     pretty-print probabilities
  rlda-xml-prob-out ... pretty-print probabilities in XML format

The arguments for the various commands are specific to the particular
command, and often include options and/or file names.  Use --help after the
command for more information.
EOF
}

RUN_SBT="$JAVA -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=256m -Xmx512M -Xss2M -jar $TEXTGROUNDER_DIR/bin/sbt-launch-*.jar"

execute()
{
  local CD
  if [ "$1" = "--cd" ]; then
    CD=true
    shift
  else
    CD=false
  fi
  RUNCMD="$1"; shift
  if [ "$VERBOSE" = true ]; then
    if [ "$CD" = true ]; then
      echo Executing: cd $TEXTGROUNDER_DIR
    fi
    echo Executing: $RUNCMD ${1+"$@"}
  fi
  if [ "$CD" = true ]; then
    cd $TEXTGROUNDER_DIR
  fi
  $RUNCMD ${1+"$@"}
}

if [ "$CMD" = 'build' ]; then

  # We need to cd to the top-level TextGrounder dir when running SBT,
  # so the proper build.sbt file gets picked up, etc.
  execute --cd "$RUN_SBT" ${1+"$@"}

elif [ "$CMD" = 'build-all' ]; then

  # We need to cd to the top-level TextGrounder dir when running SBT,
  # so the proper build.sbt file gets picked up, etc.
  execute --cd "$RUN_SBT update compile" ${1+"$@"}

elif [ "$CMD" = 'geolocate' ]; then

  CLASS=opennlp.textgrounder.geolocate.GeolocateApp
  RUNCMD="$SCALA_COMMAND $CLASS"
  # execute() doesn't handle setting JAVA_OPTS like we do, and they can't
  # be included in a variable that is expanded and reparsed, the way that
  # RUNCMD is (the reparsing seems to pretty much only involve breaking
  # on white space).
  if [ "$VERBOSE" = true ]; then
    echo Executing: JAVA_OPTS="$JAVA_MEMORY_OPT" $RUNCMD ${1+"$@"}
  fi
  JAVA_OPTS="$JAVA_MEMORY_OPT" $RUNCMD ${1+"$@"}

else  

  CLASS=
  TGPACK=opennlp.textgrounder
  TGAPP=$TGPACK.app
  TGBAYESAPP=$TGPACK.bayesian.apps

  case $CMD in
    # Various commands
    resolve) CLASS=$TGAPP.RunResolver;;
    geotext-lp) CLASS=$TGAPP.GeoTextLabelProp;;
    import-gazetteer) CLASS=$TGAPP.ImportGazetteer;;
    import-corpus) CLASS=$TGAPP.ImportCorpus;;
    preprocess-labelprop) CLASS=$TGAPP.LabelPropPreproc;;
    write-to-kml) CLASS=$TGAPP.WriteCorpusToKML;;
    eval) CLASS=$TGAPP.EvaluateCorpus;;

    # Commands in the Bayesian code (there are many more)
    rlda-convert-from) CLASS=$TGBAYESAPP.ConvertFromRegionModelFormat;;
    rlda-convert-to) CLASS=$TGBAYESAPP.ConvertToRegionModelFormat;;
    rlda-fcrm-run) CLASS=$TGBAYESAPP.TrainFullyConstrainedRegionModel;;
    rlda-prob-out) CLASS=$TGBAYESAPP.PrettyPrintProbabilities;;
    rlda-xml-prob-out) CLASS=$TGBAYESAPP.PrettyPrintProbabilitiesXML;;
    rlda-run) CLASS=$TGBAYESAPP.TrainRegionModel;;
    spher-run) CLASS=$TGBAYESAPP.TrainSphericalModel;;

    # Misc
    run) CLASS="$1"; shift;;
    help) help; exit 1;;
    *) echo "Unrecognized command: $CMD"; help; exit 1;;
  esac

  # We need to *not* cd to the top-level TextGrounder dir, otherwise if
  # there are command-line arguments referring relatively to files, the
  # files won't be found because the lookup will be relative to the
  # wrong directory.
  execute "$JAVA_COMMAND $CLASS" ${1+"$@"}

fi
