//  AnalyzeLocationVariance.scala
//
//  Copyright (C) 2013 Ben Wing, The University of Texas at Austin
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
///////////////////////////////////////////////////////////////////////////////

package opennlp.textgrounder
package postprocess

import collection.mutable

import util.argparser._
import util.experiment._
import util.io
import util.json._
import util.math._
import util.print._
import util.spherical._
import util.textdb._
import util.time._

import util.debug._

class AnalyzeLocationVarianceParameters(ap: ArgParser) {
  var input = ap.positional[String]("input",
    help = """Corpus to analyze, a textdb database.  This needs to have
a 'positions' field, as generated by ParseTweets with 'positions'
specified as one of the fields in '--output-fields'.

The value of the parameter can be any of the following: Either the data
or schema file of the database; the common prefix of the two; or the
directory containing them, provided there is only one textdb in the
directory.""")
}

/**
 * An application to analyze the different positions seen in a given user's
 * tweets. This assumes that ParseTweets has been run with the argument
 * --output-fields 'default positions' so that a field is included that
 * contains all the locations in a user's tweets.
 */
object AnalyzeLocationVariance extends ExperimentApp("AnalyzeLocationVariance") {

  type TParam = AnalyzeLocationVarianceParameters
  type Timestamp = Long

  def create_param_object(ap: ArgParser) = new AnalyzeLocationVarianceParameters(ap)

  def initialize_parameters() {
  }

  def cartesian_product[T1, T2](A: Iterable[T1], B: Iterable[T2]
      ): Iterable[(T1, T2)] = {
    for (a <- A; b <- B) yield (a, b)
  }

  def format_fraction(frac: (Double, Double)) =
    "%.2f%%,%.2f%%" format (frac._1 * 100, frac._2 * 100)

  def fraction_from_bounding_box(sw: SphereCoord, ne: SphereCoord,
      point: SphereCoord) = {
    ((point.lat - sw.lat) / (ne.lat - sw.lat),
     (point.long - sw.long) / (ne.long - sw.long))
  }

  case class Position(
    time: Timestamp,
    coord: SphereCoord
  )

  case class User(
    user: String,
    coord: SphereCoord,
    positions: Iterable[Position]
  )

  case class LocationStats(
    user: User,
    bounding_box_sw: SphereCoord,
    bounding_box_ne: SphereCoord,
    dist_across_bounding_box: Double,
    centroid: SphereCoord,
    earliest: Position,
    latest: Position,
    avgdist_from_centroid: Double,
    mindist_from_centroid: Double,
    quantile25_dist_from_centroid: Double,
    median_dist_from_centroid: Double,
    quantile75_dist_from_centroid: Double,
    maxdist_from_centroid: Double,
    maxdist_between_points: Double,
    dist_from_centroid_variance: Double
  ) {
    def get_fraction(coord: SphereCoord) =
      fraction_from_bounding_box(bounding_box_sw, bounding_box_ne, coord)

    def get_format_fraction(coord: SphereCoord) =
      format_fraction(get_fraction(coord))

    def output_position(pos: Position, tag: String) {
      errprint("  %s: %s at fraction %s, %.2f km from centroid",
        tag, pos.coord.format, get_format_fraction(pos.coord),
        spheredist(pos.coord, centroid))
      errprint("  %s time: %s", tag, format_time(pos.time * 1000))
    }

    def pretty_print() {
      errprint("User: %s, %s positions", user.user, user.positions.size)
      errprint("  bounding box: %s to %s, dist across: %.2f km",
        bounding_box_sw.format, bounding_box_ne.format,
        dist_across_bounding_box)
      errprint("  centroid: %s at fraction %s",
        centroid.format, get_format_fraction(centroid))
      output_position(earliest, "earliest")
      output_position(latest, "latest")
      errprint("  dist from centroid: avg %.2f km, median %.2f km, std dev %.2f km",
        avgdist_from_centroid, median_dist_from_centroid,
        math.sqrt(dist_from_centroid_variance))
      errprint("  quantiles dist from centroid in km:")
      errprint("    min %.2f, 25%% %.2f, median %.2f, 75%% %.2f, max %.2f",
        mindist_from_centroid, quantile25_dist_from_centroid,
        median_dist_from_centroid, quantile75_dist_from_centroid,
        maxdist_from_centroid)
      errprint("  max dist between points: %.2f km", maxdist_between_points)
    }
  }

  /** Compute centroid, average distance from centroid, max distance
    * from centroid, variance of distances, max distance between any two
    * points. */
  def compute_location_stats(user: User) = {
    val positions = user.positions.toIndexedSeq
    val points = positions.map(_.coord)
    val centroid = SphereCoord.centroid(points)
    val raw_distances = positions.map {
      case Position(ts, coord) => (ts, spheredist(coord, centroid))
    }
    val distances = raw_distances.map(_._2).sorted
    val ts_points_by_time = positions.sortBy(_.time)
    val earliest = ts_points_by_time.head
    val latest = ts_points_by_time.last
    val bounding_box_sw = SphereCoord.bounding_box_sw(points)
    val bounding_box_ne = SphereCoord.bounding_box_ne(points)

    LocationStats(
      user = user,
      bounding_box_sw = bounding_box_sw,
      bounding_box_ne = bounding_box_ne,
      dist_across_bounding_box = spheredist(bounding_box_sw, bounding_box_ne),
      centroid = centroid,
      earliest = earliest,
      latest = latest,
      avgdist_from_centroid = mean(distances),
      mindist_from_centroid = distances.head,
      quantile25_dist_from_centroid = quantile_at(distances, 0.25),
      median_dist_from_centroid = quantile_at(distances, 0.5),
      quantile75_dist_from_centroid = quantile_at(distances, 0.75),
      maxdist_from_centroid = distances.last,
      // FIXME: This is O(N^2)! Seems to me that the maximum distance
      // between any two points should involve two points on the convex
      // hull, so we first should compute the convex hull and eliminate
      // points not on the hull.
      maxdist_between_points = cartesian_product(points, points).map {
        case (a, b) => spheredist(a, b)
      }.max,
      dist_from_centroid_variance = variance(distances)
    )
  }

  def run_program(args: Array[String]) = {
    val filehand = io.localfh
    val users = TextDB.read_textdb(filehand, params.input) map { row =>
      val positions = Decoder.string_map_seq(row.gets("positions")).
        map {
          case (timestamp, coord) => Position(
            timestamp.toLong, SphereCoord.deserialize(coord))
        }
      User(row.gets("user"), SphereCoord.deserialize(row.gets("coord")),
        positions)
    }
    val stats = users map compute_location_stats
    // stats foreach { x => errprint("%s", pretty_json(x)) }
    stats foreach { _.pretty_print }
    0
  }
}
